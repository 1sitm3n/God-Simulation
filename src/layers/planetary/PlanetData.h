#pragma once

#include "Heightmap.h"
#include "Biome.h"
#include "core/util/Types.h"
#include "core/serialise/BinaryStream.h"

#include <vector>
#include <string>

namespace godsim {

/// Complete planetary data for one world.
/// Holds all the spatial grids generated by the terrain and climate pipelines.
struct PlanetData {
    std::string name = "Terra";

    // ─── Spatial Grids ───
    Heightmap elevation;     // [0, 1] normalised height
    Heightmap temperature;   // Approximate °C
    Heightmap moisture;      // [0, 1]
    std::vector<BiomeType> biome_map; // One per cell

    // ─── Parameters ───
    f32 sea_level = 0.4f;
    u32 width  = 0;
    u32 height = 0;

    // ─── Derived Stats ───
    f32 land_fraction = 0.0f;
    f32 avg_temperature = 0.0f;
    f32 avg_moisture = 0.0f;

    /// Classify all cells into biomes based on current elevation/temperature/moisture.
    void classify_biomes() {
        biome_map.resize(width * height);

        i32 biome_counts[static_cast<int>(BiomeType::COUNT)] = {};

        for (u32 y = 0; y < height; y++) {
            for (u32 x = 0; x < width; x++) {
                f32 e = elevation.get(x, y);
                f32 t = temperature.get(x, y);
                f32 m = moisture.get(x, y);

                BiomeType biome = classify_biome(e, t, m, sea_level);
                biome_map[y * width + x] = biome;
                biome_counts[static_cast<int>(biome)]++;
            }
        }

        // Compute statistics
        i32 land_cells = 0;
        for (u32 i = 0; i < width * height; i++) {
            if (elevation.data_ptr()[i] >= sea_level) land_cells++;
        }
        land_fraction = static_cast<f32>(land_cells) / (width * height);
        avg_temperature = temperature.average();
        avg_moisture = moisture.average();
    }

    /// Get the biome at a specific cell.
    BiomeType biome_at(u32 x, u32 y) const {
        return biome_map[y * width + x];
    }

    // ─── Serialisation ───
    void serialise(BinaryWriter& writer) const {
        writer.write_string(name);
        writer.write_u32(width);
        writer.write_u32(height);
        writer.write_f32(sea_level);
        elevation.serialise(writer);
        temperature.serialise(writer);
        moisture.serialise(writer);

        // Biome map
        writer.write_u32(static_cast<u32>(biome_map.size()));
        for (auto b : biome_map) {
            writer.write_u8(static_cast<u8>(b));
        }
    }

    void deserialise(BinaryReader& reader) {
        name = reader.read_string();
        width = reader.read_u32();
        height = reader.read_u32();
        sea_level = reader.read_f32();
        elevation.deserialise(reader);
        temperature.deserialise(reader);
        moisture.deserialise(reader);

        u32 biome_count = reader.read_u32();
        biome_map.resize(biome_count);
        for (u32 i = 0; i < biome_count; i++) {
            biome_map[i] = static_cast<BiomeType>(reader.read_u8());
        }

        // Recompute stats
        i32 land_cells = 0;
        for (u32 i = 0; i < width * height; i++) {
            if (elevation.data_ptr()[i] >= sea_level) land_cells++;
        }
        land_fraction = static_cast<f32>(land_cells) / (width * height);
        avg_temperature = temperature.average();
        avg_moisture = moisture.average();
    }
};

} // namespace godsim
